<!-- <!DOCTYPE html> -->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Tremor analysis using Leap Motion</title>
		<meta name="author" content="FÃ¡bio Henrique M. Oliveira">
		<style>
			#canvas {
				float: right;
				width: 50%;
				height: 50%;
				border: 1px solid #000000;
			}
			/*#connectButton {
			 position: relative;
			 bottom: 0 px;
			 }*/
			#logTextArea {
				float: right;
				width: 50%;
				height: 50%;
			}
		</style>
		<script type="text/javascript" src="leap.js"></script>
		<script type="text/javascript" src="canvasjs.min.js"></script>		
	</head>
	<body>

		<canvas id="canvas" ></canvas>
		<button id="connectButton" onclick="controller.connect()">
			Connect controller
		</button>
		<button id="disconnectButton" onclick="controller.disconnect()">
			Disconnect controller
		</button>
		<div id="chartContainer" style="height: 300px; width:550px;"></div>
		<textarea id="logTextArea" readonly="true">LOG:</textarea>														
		
		<script>
            // Get the canvas DOM element
            var canvas = document.getElementById('canvas');

            // Making sure we have the proper aspect ratio for our canvas
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            // Create the context we will use for drawing
            var c = canvas.getContext('2d');

            // Save the canvas width and canvas height
            // as easily accesible variables
            var width = canvas.width;
            var height = canvas.height;

            // Get the textarea DOM element to allow edit before
            var logTextArea = document.getElementById('logTextArea');

            // Creating a global Frame variable that we can access
            // throughout the program
            //var frame;

            // number of dataPoints visible at any point
            var dataLength = 300;
            // dataPoints
            var dps = [];
            // Chart
            var chart;

            // Vars to control the time (to use in the charts)
            var firstTimestamp = 0;
            var currentTimestamp = 0;
            var lastTimestamp = 0;
            var frameId = 0;
			
            // Qtd frames/second
            var frameRate = 60;
            // time to wait between frames in microsecond (/1000000 = 0.01 seconds)
            var framePause = (1/frameRate)*1000000;
            
            /*

             The leapToScene function takes a position in leap space
             and converts it to the space in the canvas.

             It does this by using the interaction box, in order to
             make sure that every part of the canvas is accesible
             in the interaction area of the leap

             */
            function leapToScene(leapPos, frame) {

                // Gets the interaction box of the current frame
                var iBox = frame.interactionBox;

                // Gets the left border and top border of the box
                // In order to convert the position to the proper
                // location for the canvas
                var left = iBox.center[0] - iBox.size[0] / 2;
                var top = iBox.center[1] + iBox.size[1] / 2;

                // Takes our leap coordinates, and changes them so
                // that the origin is in the top left corner
                var x = leapPos[0] - left;
                var y = leapPos[1] - top;

                // Divides the position by the size of the box
                // so that x and y values will range from 0 to 1
                // as they lay within the interaction box
                x /= iBox.size[0];
                y /= iBox.size[1];

                // Uses the height and width of the canvas to scale
                // the x and y coordinates in a way that they
                // take up the entire canvas
                x *= width;
                y *= height;

                // Returns the values, making sure to negate the sign
                // of the y coordinate, because the y basis in canvas
                // points down instead of up
                return [x, -y];

            }

            // Creates our Leap Controller
            var controller = new Leap.Controller({enableGestures: false, frameEventName: 'deviceFrame'});
            //console.log(controller.frame());
            // Initializes the chart
            initChart();

            // Tells the controller what to do every time it sees a frame
            controller.on('frame', function(frame) {

                // Assigning the data to the global frame object
                //frame = data;

                //Clears the canvas so we are not drawing multiple frames
                c.clearRect(0, 0, width, height);

                // First we loop through all of the hands that the frame sees
                // TODO: I need to restrict it for just one hand
                for (var i = 0; i < frame.hands.length; i++) {

                    // For each hand we define it
                    var hand = frame.hands[i];
					// difference between time stamps
                    var timeDifference = frame.timestamp - lastTimestamp;
                                        
                    if (frameId == 0 && frame.valid) {
                        logTextArea.value += '\n--- Updated every '+framePause/1000000 +' seconds ---\n\nFrame id: ' + frame.id + '	Timestamp: ' + frame.timestamp + '\nHand time visible: ' + hand.timeVisible + ' seconds';
                        logTextArea.value += '\nTime: ' + currentTimestamp + ' seconds\n';
                        firstTimestamp = frame.timestamp;
                        frameId = frame.id;
                        timeDifference = 0;
                        lastTimestamp = frame.timestamp;
                    }
                                        
                    if (timeDifference > framePause) {
                        currentTimestamp = (frame.timestamp - firstTimestamp)/1000000;
                        logTextArea.value += '\nFrame id: ' + frame.id + '	Timestamp: ' + frame.timestamp + '\nHand time visible: ' + hand.timeVisible + ' seconds';
                        logTextArea.value += '\nTime: ' + currentTimestamp + ' seconds\n';
                        // To keep textarea scrolled to the bottom when updated
                        logTextArea.scrollTop = logTextArea.scrollHeight;
                        
                        updateChart(hand);

                        frameId = frame.id;
                        lastTimestamp = frame.timestamp;
                    }

                    // and get its position, so that it can be passed through
                    // for drawing the connections
                    var handPos = leapToScene(hand.palmPosition, frame);

                    // Loop through all the fingers of the hand we are on
                    for (var j = 0; j < hand.fingers.length; j++) {

                        // Define the finger we are looking at
                        var finger = hand.fingers[j];

                        // and get its position in Canvas
                        var fingerPos = leapToScene(finger.tipPosition, frame);

                        /*
                        First Draw the Connection
                        */

                        // Setting up the style for the stroke
                        c.strokeStyle = "#FFA040";
                        c.lineWidth = 3;

                        // Drawing the path
                        c.beginPath();

                        // Move to the hand position
                        c.moveTo(handPos[0], handPos[1]);

                        // Draw a line to the finger position
                        c.lineTo(fingerPos[0], fingerPos[1]);

                        c.closePath();
                        c.stroke();

                        /*
                        Second Draw the Finger
                        */

                        // Setting up the style for the stroke
                        c.strokeStyle = "#39AECF";
                        c.lineWidth = 5;

                        // Creating the path for the finger circle
                        c.beginPath();

                        // Draw a full circle of radius 6 at the finger position
                        c.arc(fingerPos[0], fingerPos[1], 20, 0, Math.PI * 2);

                        c.closePath();
                        c.stroke();

                    }

                    /*
                    Third draw the hand
                    */

                    // Setting up the style for the fill
                    c.fillStyle = "#FF5A40";

                    // Creating the path for the hand circle
                    c.beginPath();

                    // Draw a full circle of radius 10 at the hand position
                    c.arc(handPos[0], handPos[1], 40, 0, Math.PI * 2);

                    c.closePath();
                    c.fill();

                }

            });

            controller.on('connect', function() {

                logTextArea.value += '\n---Successfully connected---';

            });

            controller.on('disconnect', function() {

                logTextArea.value += '\n---Disconnected---';

            });

            // Get frames rolling by connecting the controller
            //controller.connect();

            function initChart() {
				
                chart = new CanvasJS.Chart("chartContainer", {
                    zoomEnabled: true,
					title : {
                        text : "Palm Velocity",
                        fontSize: "18",
                    },
                    data : [{
                        type : "line",
                        name: "Palm velocity (norm)",
                        showInLegend: true,
                        dataPoints : dps,
                    }],
                    axisX:{
                    	title: "seconds",
                    	//interval: framePause/1000000,
   						intervalType: "second",
      					//suffix: " s",
    				},
    				axisY:{
    					title: "millimeters",
    					minimum: 0,
    					maximum: 500,
    					//suffix: " mm",
    				},
    				legend:{
  						fontSize: 14,
 					}
                });
            }

            function updateChart(hand) {

                dps.push({
                    x : currentTimestamp,
                    y : normalize3DVector(hand.palmVelocity)
                });

                if (dps.length > dataLength) {
                    dps.shift();
                }

                chart.render();
            }
            // Get the velocity of the hand (norm)
			function normalize3DVector(vector){
				return Math.sqrt(vector[0]*vector[0] + vector[1]*vector[1] + vector[2]*vector[2]);				
			}
		</script>

	</body>
</html>